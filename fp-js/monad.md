## 谦逊的monad

我在这章中引入monad这个话题是因为这是每个开发者在学习函数式编程时会遇到的一个历程，就如同我在这章所写的。

我们对monad以简短的一瞥来基本结束这本书，尽管大多数函数式编程文献以单子开始。在我的“轻函数”编程中，我不需要太多去思考明确的monad这个术语，这就是为什么比起主要核心，本质能带来更多的意外收获。但是这并不是说monad并没有用或不流行，好吧，他们确实是这样。

在JavaScript函数式编程的世界中有这么一个笑话，每个人都需要对什么式单子来写他们自己的教程或帖子，就像写本书就如同成年仪式一样。过去这么多年，monad已经被描绘成各种各样了，比如墨西哥卷，洋葱以及各种各样奇怪概念的抽象。我希望这里没有这些愚蠢的实现发生。

> monad就是在类别中的独特点。

对于你离开这项讨论，我只希望你不要害怕monad这一术语或者是其他的概念，然后在看见他们的时候能够意识到他们。你可以的，甚至可以在场合中使用他们。

## 类型

在FP中有很多有意思的领域，我们在本书中完全避免了这个领域：类型理论。我不打算深入类型理论，坦白的说，是因为我没有能力去做这件事。即使我做了，你也不会去欣赏它。

但是我将要说的是，monad是基本的值类型。

数值 42 是值类型（数字），这个类型直接带来了特点和我们所以来的能力。字符串“42”可能看起来非常简单，但是在我们的程序中它有着不同的用途。

在面向对象编程中，当你使用一组数据（甚至是单个离散的数值）以及当你有想要将它们捆绑在一起的行为时，你创建了对象/类来代表这种类型。实际上他们是这种类型的成员。这种寻常的行为被称为“数据结构”。

我将在这里松散地使用数据结构的概念，然后断言我们可能在编程中找到有用的方法为直接的数据去定义一组行为或限制，然后将它们和那个值一个绑定到单个抽象中。以这种方法，当我们在编程中运用一个或多个这种类型的数据时，它们的行为都是免费的以及运用它们更加的便利。通过这种方便的方式，对于读者和你的代码来说将变得更加声明式和可用的。

monad是一个数据结构。它是一个类型。它有一组能够明确设计去生成可预测的值的行为。

回想第九章我们对functors的讨论：一个值和一个类数组的方法，对它所有的组成数据成员执行操作。monad 就是一个包含了一些额外行为的functor。

## 宽松的接口

确切的说，monad 不是单个数据类型，它更像是一个数据类型的相关集合。这是一个依赖于不同值需求的不同实现接口。每个实现都有一个不同的monad。

举例来说，你可能有看到过“验证monad”，“输入输出monad”，“可能性monad”，“其中monad”或者是其他的。其中每个都有被定义的monad基础行为，但是它们根据个不同类型的monad 的用例，来扩展或重载交互。

它比接口有过之，因为这不只是使对象为monad的API方法的存在。这是一组关于必要方法相互作用的确切保证。人尽皆知的不变的事实是，有必要通过熟悉使用monads来提高可读性；否则，这就是一组需要读者去完全阅读去理解的特殊数据结构。

事实上，在这些monadic的方法命名上，并没有一个统一的认同，正确的接口方法就是mandate的；monad更像一个松散的接口。有些人称为直接的方法`bind( .. )`, 有些人称`chain( .. )`, 有些人称`fiatMap( .. )`。

所以monad就是一个带有足够的方法的对象数据结构，这些方法至少满足了monad定义的主要行为需求。每个类型的monad在最小基础之上有着不同的扩展。但是，由于它们在行为上有所叠加，将两个不同类型的monads放在一起仍然将是直率且可预测的。

在感觉上来讲，monads就类似于接口。

## Just a Monad

基于许多其他你将运行的monad的最原始monad被称为**Just**。它对于任何规则的值，只是一层简单的monadic包装。

因为monad是一个类型，你可能想到像 class 一样去定义 `just` 然后变成实例。这是一个可行的方法，但是它在方法中引入 `this`绑定问题；相反地，我只想坚持简单的函数方法。

这是基础的实现：

```js
function Just(val) {
    return { map, chain, ap, inspect };

    // *********************

    function map(fn) { return Just( fn( val ) ); }

    // aka: bind, flatMap
    function chain(fn) { return fn( val ); }

    function ap(anotherMonad) { return anotherMonad.map( val ); }

    function inspect() {
        return `Just(${ val })`;
    }
}
```

你可能注意到，无论`Just`实例接受的值是多少，它从不改变。所有的monad方法创建了一个单独的monad实例，而不是改变monad的值本身。

如果这些都不能让你有感觉，不要担心。我们不要太过于被这些设计monad的理论细节所迷住。相反的，我们应该更加专注于描述我们可以用它们做些什么。

## 使用Monad方法

所有monad实例将有`map`,`chain`,`ap` 方法。这些方法和行为的目的是为了提供与其他多个monad实例互相交互的标准方法。 

首先看向 `map( .. )`函数。就如同数组的`map( .. )` 方法一样，monad的`map( .. )`以monad的值来调用mapper函数，然后不论返回的值，都是一个被包裹的新的`Just`实例：

```js
var A = Just( 10 );
var B = A.map( v => v * 2 );

B.inspect();                // Just(20)
```

Monadic `chain( .. )`做的事和`map`有点像，但是它是从新的monad返回的未包裹的结果值。然而，和我们所想的关于“未包裹”的monad不太一样，更加规范的解释是，`chain( .. )`使monad趋于平缓。如下：

```js
var A = Just( 10 );
var eleven = A.chain( v => v + 1 );

eleven;                     // 11
typeof eleven;              // "number"
```

`eleven` 是真正的原始值11，不是维持这这个值的monad。

 和 `flatMap( .. )` 所做的一样。和 `map` 维持值不同，`chain( .. )` 另外磨平了monad到基本的值。

一个方式去解释 `chain( .. )` 是和 `identity( .. )` 方法组合，来有效地从monad中提取值: 

```js
var identity = v => v;

A.chain( identity );        // 10
```

`A.chain( .. )`以在A中的值来调用 `identity`，不论 `identity`返回的值只是直接产出没有任何干预的monad。换句话说，早在 `just( .. )` 代码列出之前，我们没必要包括选择性的 `inspect` 函数，因为 `chain(identuty)` 完成了同样的目标；在我们学习monads时进行测试案例时是纯净的。

在这一点上，希望对于包括 `map` 和 `chain` 对你来说都是感到相当合理的。

通过对比，monad的 `ap( .. )`方法比起最初的一瞥将显得更加不直观的。这将像奇怪的交互扭曲，但是除了设计以外，这有更深和重要的理由。让我们花费点时间来突破这个方面。

`ap` 接受被包装在monad中的值以及通过使用其他monad的 `map`来调用它到别的monad中。

然而，`map` 经常预期一个函数。这意味着你调用 `ap`的monad必须直接包含函数作为他的值，然后传递这个值到别的monad的 `map`中。

感到混乱吗？好吧，这不是你想的那样，我将产生简单的解释，但是只要想象这些事将会造成一段时间的迷惑，知道你对monad有了更多的实践和暴露。

我们定义 `A` 作为包含值10的monad，以及 `B` 作为包含值3的monad。

```js
var A = Just( 10 );
var B = Just( 3 );

A.inspect();                // Just(10)
B.inspect();                // Just(3)
```

现在，我们应该如何创造一个新的monad呢？这个monad通过 `sum`这个函数会把值10和3添加到一起。答案是 `ap`的帮助。

通过使用 `ap`，我们说我们首先需要维系一个函数的monad这样一样结构。详细点说，我们需要一个维系函数，这个函数通过闭包来维系着在A中的值。

