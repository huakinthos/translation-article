## 为什么是函数式编程？

函数式编程(FP)在任何意义上都不是一个新概念。它几乎贯穿完整的编程历史。然而，我不确定的说，直到近几年，世界上的开发者整体才将其视为主流的观念。我认为FP更加为学术领域。

尽管现在所有都在改变，对于FP的兴趣风潮正在兴起，不只是在语言程度上还有在类库和框架上。你可能正在读这段文字因为你意识到FP是一件你不能忽视的东西。或者是你像我一样在之前多次尝试学习FP，但是尽力地去读完所有术语或数学概念。

第一章的目的是回答像“为什么我要在我的代码中使用FP风格？”和“函数式JavaScript和别人所说的FP相比如何？”这类问题。在我们打下基础之后，一块一块地看，在这本书的剩余部分我们将解开谜底。

## 初见

让我通过下面的代码片段，简短地描述函数式JavaScript这一概念：

```js
var numbers = [4,10,0,27,42,17,15,-6,58];
var faves = [];
var magicNumber = 0;

pickFavoriteNumbers();
calculateMagicNumber();
outputMsg();                // The magic number is: 42

// ***************

function calculateMagicNumber() {
    for (let fave of faves) {
        magicNumber = magicNumber + fave;
    }
}

function pickFavoriteNumbers() {
    for (let num of numbers) {
        if (num >= 10 && num <= 20) {
            faves.push( num );
        }
    }
}

function outputMsg() {
    var msg = `The magic number is: ${magicNumber}`;
    console.log( msg );
}
```

现在思考下一完成相同的结果但是完全不同的风格的代码：

```js
var sumOnlyFavorites = FP.compose( [
    FP.filterReducer( FP.gte( 10 ) ),
    FP.filterReducer( FP.lte( 20 ) )
] )( sum );

var printMagicNumber = FP.pipe( [
    FP.reduce( sumOnlyFavorites, 0 ),
    constructMsg,
    console.log
] );

var numbers = [4,10,0,27,42,17,15,-6,58];

printMagicNumber( numbers );        // The magic number is: 42

// ***************

function sum(x,y) { return x + y; }
function constructMsg(v) { return `The magic number is: ${v}`; }
```

一旦你理解了FP，这可能你你阅读和处理第二段代码的方法：

> 我们首先创建了一个叫 `sumOnlyFavorites`函数，这个函数是其他三个函数的组合。我们组合了两个 filters，一个

所有这些可移动的块以你现在极度模式的方式来告诉FP开发者。本书将帮助你用同样的方式来推理，然后这将对你来说是可读的就像其他代码。

一些关于这种代码对比的评价：

- 对许多读者来说，前面的代码比起后面的代码更加舒服/可读/可维护。如果有这种感觉这是完全可以的。你来对地方了。我敢确信如果你读完了这本书，以及做了所有我所说的实践，第二种代码片段将最终变得更加自然，你可能更加喜欢！
- 我所完成的任务可能和前面所出现的片段完全不同。这也是能接受的。这本书演示不是指定性的，你可以以不特殊的方式做同样的事。在这本书的最后，你是如何完成这项任务比起现在所完成的可能更加贴近第二段代码。
- 当然你也可能早就是一个有经验的FP开发者，可以扫视这本书的开始选择有没有任何对你有用的去看。第二段片段无疑是有点熟悉的。

无论你是什么理由来看的，都非常欢迎！

## 信心

我有一个简单的前提，可以说是我所做为软件开发教师的一切的基础：你不能确信的代码是你没理解的代码。相反也是对的：你没理解的代码是你不能信任的代码。更多的是，如果你不能信任或理解你的代码，任何你所写的代码组成的任务，你都没有信心。你运行这个程序，然后只能祈祷好运。

我通过信任想说明什么？我想说你可以通过阅读或推理来验证，但不能只执行。这样你可以理解你的一段代码将会做什么；你不能够只依赖于他该干什么。这可能比谨慎的做法更常见，我们趋向依赖运行测试去验证我们的程序的正确性。我不是说去测试是坏的。但是我认为我们应该渴望能够理解我们的代码，知道测试将在运行前通过。

组成FP基础的技术是从仅仅通过阅读我们的程序就能有更多的自信来被设计的。一些理解FP以及在他们的程序中遵守纪律勤奋地使用它们的人，将写出他们和别人可以阅读和验证的程序将依照他们所想所做的代码。

当我们使用像避免或最小化错误资源的技术时，自信也会提高。这可是是FP最大的卖点之一：FP程序有更少的漏洞，而且这也存在的漏洞经常在明显的地方，所以更加容易找到并修复它们。FP代码更趋向漏洞抵抗性，甚至不存在漏洞。

在你于这本书的旅途中，你将在你所写的代码中开发更多的自信，因为你将使用早就被很好证实的模式和实践；以及你将避免最常见的程序漏洞的原因。

## 沟通

为什么函数式编程这么重要？为了回答这个问题，我们需要返回一大步以及讨论编程自身为什么重要。

你听到这个可能会感到惊讶，但是我不认为代码对电脑来说原本是一组指令。事实上，我认为代码指示电脑这一事实是一个幸运的意外。

我十分相信，代码非常重要的作用是作为一种作为与他人沟通的手段。

你可能知道这样一种经历，你大量的花费在编程上的时间实际上是花费在阅读现有的代码。很少人能有幸去花费全部或者是大多数时间简单的敲除新代码以及从不处理别人所写的代码。

一个普遍的估计，开发者花费70%的代码维护时间在阅读去理解它。70%，真是令人大开眼界！难怪对于开发者每日所写的代码行数的全球平均量是10行。我们每天花费7个小时只是去阅读代码然后想象出这10行代码因该在哪运行。

我们因该花费更多的时间在代码的可读性上。顺便说一下，可读性不仅仅只是几个字符而已。可读性大多数被熟悉程度所影响。

如果我们花费时间在关心创作更加可读和理解的代码，FP是这种努力的中心。FP的原则得到充分的建立，深层次的研究以及考察，以及证明可验证的。花费时间去学习和运用这些FP原则将根本上地带来可读性和对你和别人代码的认知。代码熟悉的提升以及这种认知的权衡将提升代码的可读性。

举个例子，一旦你学到 `map` 所做的，当你看见它在任何程序中你将能够大部分立即反应和理解它们。但是每次你见到for循环，你必须去阅读整个循环然后去理解它们。for循环的语法可能是熟悉的，但是它所作的本质你可能不知道。那么你就必须每次都要去阅读。

通过有更多的能够一眼就能认知的代码，然后花费更少的时间想象它们干了什么，我们的注意力就会空出来去思考更高层次的代码逻辑；不管如何这是一项更需要我们注意力的东西。

FP（至少，没有术语来拖累它）是一项提升可读性非常有效的工具。这就是为什么它非常重要。

## 可读性

可读性很大程度是描述我们与代码关系的主观的人为因素。以及它自然地随着时间的推移和我们的技能和理解力的提升来变化。我的经历和下面图相似，以及大多数我所提到的人也有着一样的经历。

![](https://raw.fastgit.org/getify/Functional-Light-JS/master/manuscript/images/fig17.png)

在你阅读这本树的过程中，你可能发现你也会经历着相同的影响。但是要注意了，如果你一旦超过一个点，这个曲线就会回来！

*命令式*  描述了大多数我们早就自然地写出的代码；现在关注到先前提到的指示电脑如何做某事。*声明式*  编程 -- 一种我们将要学习去写的方式，它坚持FP的原则 -- 是更加关注于描述结果是什么的代码。

让我们重新看向两段在这章先前出现的代码。

第一段代码是命令式的，它完全是关注于如何做任务；它以 `if` 声明，`for` 循环，临时变量，变量覆盖，值改变和带有副作用的函数调用到处散落着。你确实可以通过这种逻辑来追踪来看看数值是如何流动的以及改变最后的状态，但是这并不清楚和直率的。

第二段代码段更加声明式；它去掉了大多数之前提到的命令式技术。注意这没有显式的情况，循环，副作用，再覆盖或修改；取而代之的，它运用了像filtering，reduction，transducing和compose这些有名的以及可信的模式。关注点从低阶到如何关注于结果的高阶转变。

和带有 `if` 声明来测试数字的混杂代码不同，我们以熟知的FP方法像 `gte( .. )` (greater-then-or-equal-to)来代理，然后关注共重要的组合任务。

此外，第二个程序的数据流是显式的：

1. 一组数据传入 `printMagicNumber`
2. 每次一个，这些数值通过 `sumOnlyFavorites` 被传递，结果是单个总数，包含了我们所喜欢的几种数值。
3. 这个总数以 `constructMsg` 转变为字符串类型。
4. 这个字符串信息通过 `console.log` 被打印到控制台。

你可能仍然认为这种方法是复杂的，而命令式片段更加容易去理解。你要去适应它；熟悉感在我们的可读性上会有深远的影响。在这本书的最后，你将会消化第二种声明式方法的利益，然后熟悉会使可读性变得栩栩如生。

这需要很大的努力，以及更多的代码来提升读写能力，然后最小化或消除会带来漏洞的错误。说真的，当我开始写这本书的时候，我不能够写出第二段代码，或是完全理解它。当我开始沿着我学习的旅途越走越远后，它变得更加自然和舒适。

如果你希望FP重构，那么快速改变你的代码变得更加优雅，清晰 -- 这种方式在短期内变得简单 -- 不幸的是这不是现实的期望。

FP是一种非常难去思考如何该结构化的方式吗，为了让数据流更加清晰明显以及帮助你的阅读者跟随你的思考。这将非常花费时间。这种努力是非常值得的，但是这将是一场艰苦的旅行。

在我结束了某些对我来说足够清晰去理解的东西后，这仍然要花费我多重注意力去重构命令式代码片段到更加声明式的FP。我发现转换到FP是一种缓慢的迭代过程，而不是从一个范式到另一个范式的快速二进制改变。

我经常运用“再它之后再教一遍”来测试每个我所写的代码段。当我写完一段代码，我将他放置几个小时或几天，然后我尝试以第一次见它的方式来阅读它，然后假装我要教或解释给某人一样。在前几次这是很混乱的，所以我调整然后重复这种操作。

我不是想要贬低你的精神。我真的想让你将这些杂草清除掉。当我做这件事时我很自豪。我最终可以看到曲线向上攀登来提升可读性。这种努力是值得的。这对你来说也将一样！

## 观点

大多数FP文献似乎都是自上而下的方法，但是我们将以相反的方向进行：从头做起，我们将打开最基础的原则，我相信这个原则是正式FP人做任何事的脚手架。

